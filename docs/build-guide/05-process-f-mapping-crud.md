### 3.C — Individual Processes

Build in this order. Process F is fully detailed as the template; subsequent processes fully detail unique patterns but reference Process F for shared patterns (Start shape, Return Documents, profile import).

---

### Process F: Mapping CRUD (`PROMO - Mapping CRUD`)

> **API Alternative:** This process can be created programmatically via `POST /Component` with `type="process"`. Due to the complexity of process canvas XML (shapes, routing, DPP mappings, script references), the recommended workflow is: (1) build the process manually following the steps below, (2) use `GET /Component/{processId}` to export the XML, (3) store the XML as a template for automated recreation. See [Appendix D: API Automation Guide](22-api-automation-guide.md) for the full workflow.

This is the simplest process — a good "hello world" to validate the FSS-to-process pipeline before tackling complex logic.

#### Profiles

| Profile | Source File |
|---------|------------|
| `PROMO - Profile - ManageMappingsRequest` | `/integration/profiles/manageMappings-request.json` |
| `PROMO - Profile - ManageMappingsResponse` | `/integration/profiles/manageMappings-response.json` |

The request JSON contains:
- `action` (string): one of `"query"`, `"update"`, `"delete"`
- `devComponentId` (string, conditional): the dev component ID to query, update, or delete
- `devAccountId` (string, conditional): the dev account ID — required for update/delete (compound match key with `devComponentId`)
- `prodComponentId` (string, conditional): the production component ID (used by update)
- `componentName` (string, conditional): human-readable name (used by update)
- `componentType` (string, optional): component type (e.g., `"process"`, `"connector-settings"`); useful for admin seeding

The response JSON contains:
- `success`, `errorCode`, `errorMessage` (standard error contract)
- `mappings` (array): returned mapping records (for query operations), each with `devComponentId`, `devAccountId`, `prodComponentId`, `componentName`, `componentType`, `mappingSource`, `lastPromoted`

> **DataHub auto-generated XML profiles:** Each DataHub operation (Query, Update, Delete) auto-generates its own XML request and response profiles when you click **Import** in the operation's Request/Response profile panel. These are separate from the JSON FSS profiles listed above. You will have:
> - 2 JSON profiles (FSS request/response — the ones in `/integration/profiles/`)
> - 6 XML profiles (auto-generated by the 3 DataHub operations: Query, Update, Delete × request/response)
>
> The Map shapes in each branch convert between the JSON FSS format and the DataHub XML format.

#### FSS Operation

1. Create `PROMO - FSS Op - ManageMappings` per the pattern in Section 3.B
2. Service Type: Message Action
3. Request Profile: `PROMO - Profile - ManageMappingsRequest`
4. Response Profile: `PROMO - Profile - ManageMappingsResponse`

#### Canvas — Shape by Shape

1. **Start shape**
   - Double-click the Start shape on the new process canvas
   - Connector: **Boomi Flow Services Server**
   - Action: **Listen**
   - Operation: select `PROMO - FSS Op - ManageMappings`
   - This receives the request JSON from the Flow Service

2. **Set Properties** (read request fields into DPPs)
   - Drag a **Set Properties** shape onto the canvas; connect Start to it
   - Add property: DPP `action` = read from document using JSON profile `PROMO - Profile - ManageMappingsRequest`, path: `action`

3. **Route** (branch on action type)
   - Drag a **Route** shape onto the canvas; connect Set Properties to it
   - Route on: DPP `action`
   - Define 4 named branches:
     - `query` — routes to the Query branch (DPP `action` **EQUALS** `"query"`)
     - `update` — routes to the Update branch (DPP `action` **EQUALS** `"update"`)
     - `delete` — routes to the Delete branch (DPP `action` **EQUALS** `"delete"`)
     - `default` — catches invalid action values; routes to an error response

   > **Why Route instead of Decision?** Boomi Decision shapes are binary (TRUE/FALSE). With 3 distinct actions plus a default, a Route shape provides named multi-branch routing based on a DPP value. Each branch has its own connector and connection to the next shape.

#### Query Branch (action = "query")

4. **Map — JSON request to DataHub Query XML**
   - Source profile: `PROMO - Profile - ManageMappingsRequest` (JSON)
   - Destination profile: DataHub ComponentMapping query request (XML, auto-generated)
   - Map `devComponentId` → query filter field (if provided; omit for "return all" query)
   - Map `devAccountId` → query filter field (if provided)

5. **Connector — DataHub Query**
   - Connector: `PROMO - DataHub Connection`
   - Operation: `PROMO - DH Op - Query ComponentMapping`
   - If both `devComponentId` and `devAccountId` are provided, the query filters by both (exact match)
   - If only `devAccountId` is provided, returns all mappings for that dev account
   - If no filters are provided, returns all records (up to the query limit)

6. **Map — DataHub Query XML to JSON response**
   - Source profile: DataHub ComponentMapping query response (XML, auto-generated)
   - Destination profile: `PROMO - Profile - ManageMappingsResponse` (JSON)
   - Map fields:
     - Each `ComponentMapping` golden record maps to an entry in the `mappings` array
     - Map `devComponentId`, `devAccountId`, `prodComponentId`, `componentName`, `componentType`, `source` → `mappingSource`, `lastPromoted`
     - Set `success` = `true`

7. **Return Documents** — sends the mapped response JSON back to Flow

#### Update Branch (action = "update")

8. **Map — JSON request to DataHub Update XML**
   - Source profile: `PROMO - Profile - ManageMappingsRequest` (JSON)
   - Destination profile: DataHub ComponentMapping update request (XML, auto-generated)
   - The XML uses `<batch src="ADMIN_SEEDING">` wrapper for admin-initiated mappings
   - Map `devComponentId`, `devAccountId`, `prodComponentId`, `componentName`, `componentType` from the JSON request

9. **Connector — DataHub Update**
   - Connector: `PROMO - DataHub Connection`
   - Operation: `PROMO - DH Op - Update ComponentMapping`
   - DataHub creates or updates the golden record based on match rules (`devComponentId` + `devAccountId`)

10. **Map — DataHub Update XML to JSON response**
    - Source profile: DataHub ComponentMapping update response (XML, auto-generated)
    - Destination profile: `PROMO - Profile - ManageMappingsResponse` (JSON)
    - Set `success` = `true`

11. **Return Documents**

#### Delete Branch (action = "delete")

12. **Map — JSON request to DataHub Delete XML**
    - Source profile: `PROMO - Profile - ManageMappingsRequest` (JSON)
    - Destination profile: DataHub ComponentMapping delete request (XML, auto-generated)
    - Map `devComponentId` and `devAccountId` — the compound match key identifies the record to delete

13. **Connector — DataHub Delete**
    - Connector: `PROMO - DataHub Connection`
    - Operation: `PROMO - DH Op - Delete ComponentMapping`
    - Deletes the golden record matching the compound key

14. **Map — DataHub Delete XML to JSON response**
    - Source profile: DataHub ComponentMapping delete response (XML, auto-generated)
    - Destination profile: `PROMO - Profile - ManageMappingsResponse` (JSON)
    - Set `success` = `true`

15. **Return Documents**

#### Default Branch (invalid action)

16. **Map — Build error response**
    - No source document needed; build the response from static values and DPP
    - Destination profile: `PROMO - Profile - ManageMappingsResponse` (JSON)
    - Set `success` = `false`
    - Set `errorCode` = `"INVALID_ACTION"`
    - Set `errorMessage` = `"action must be one of: query, update, delete"`

17. **Return Documents**

#### Error Handling

Add a **Try/Catch** around the DataHub connector shapes (all three branches). In the Catch block:
1. Add a **Map** shape that builds the error response JSON:
   - `success` = `false`
   - `errorCode` = `"DATAHUB_ERROR"`
   - `errorMessage` = the caught exception message
2. Connect to a **Return Documents** shape

**Verify:**

- Deploy the process to your public cloud atom
- Send a test request through the Flow Service with `action = "query"` and a `devComponentId` that has no mapping
- **Expected**: response with `success = true`, `mappings = []` (empty array, since no records exist yet)
- Send a test request with `action = "update"` and populated `devComponentId`, `devAccountId`, `prodComponentId`, `componentName`
- **Expected**: response with `success = true`
- Send another `action = "query"` request with the same `devComponentId`
- **Expected**: the mapping you just created appears in the `mappings` array
- Send a test request with `action = "delete"` and the same `devComponentId` + `devAccountId`
- **Expected**: response with `success = true`
- Send a follow-up `action = "query"` — the deleted mapping should no longer appear
- Send a test request with `action = "invalid"`
- **Expected**: response with `success = false`, `errorCode = "INVALID_ACTION"`

---

---
Prev: [Phase 3: Process Canvas Fundamentals](04-process-canvas-fundamentals.md) | Next: [Process A0: Get Dev Accounts](06-process-a0-get-dev-accounts.md) | [Back to Index](index.md)
